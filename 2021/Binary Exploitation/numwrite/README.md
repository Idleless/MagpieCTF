# Introduction
Preface: I do not know how this program works. I do not know how my exploit works. I accidentally stumbled into a solution and thought that this was supposed to be an easy challenge.
This writeup is not an explanation of how poly is intended to work, it's my process of how I exploited it. For more info on the intended solution, I'd recommend checking the [official Magpie writeup.](https://github.com/infosec-ucalgary/magpieCTF-2021/tree/master/challenges/binary-exploitation/poly)

## TL;DR
Found a bug when writing 4 or more numbers as char. Expanded this to an arbatrary write. Overwrote "output.txt" and changed it to "e;cat *";

## Tools used
 - Ghidra
> For static analysis
 - Evan's Debugger (edb)
> For dynamic analysis (debugging)
 - Python
> For exploit writing/testing

# Finding a bug
## Overview of the source
The first thing I looked at was the source code(numwrite.c) to get a quick idea of what the executable is and the probable way to win.
Going through top to bottom the key things I noticed were:
- Line 25: "Why did you add char as an option?!"
> Possible hint?
- Line 39: "execv("/bin/bash", args);"
> Well that looks like a probable way to win
- Line 88/89 and 101/106: scanf("%s", buffer)
> Buffer overflow?  
> YES!!! But checking in Ghidra, there is nothing after those buffers to overwrite... =(
- Line 110: input_numbers > 256
> Possible Off by One error? The max value of a char is only 255 and this will include 256.
> It wasn't from what I could tell. Just an arbatrary value.

## Understanding the program
So running the program, I can choose how many numbers I can write, size, and a value for each number. So what are some vulnerabilities I can use?
- Buffer overflow?
> I've already checked for the number of writes and the var size but maybe I missed something? Nope, even writing ~4000 character up to the next read only memory didn't overwrite anything.  
> What about an overflow when inputing the numbers? Doesn't look like it and looking in the source code (line 70) shows them using scanf with "%ld" instead of "%s"
- Off by One?
> Is there some sort of edge case that was missed when using the numbers? Well lets try to set it to some exstreme values: 0, -1, 4294967295, 4294967296, 999999999999. Still nothing.

At this point I notice something odd that was staring me in the face, how was I setting values of 4294967295 to a char which has a max value of 255? 
Going back to the source code I found what I was looking for, lines 52 and 62: 
```
size = numbers * sizeof(char);  
list = (long *)alloca(size);
```  
They were treating all numbers as a long but only allocating space for the type requested. So if I created 4 chars(1 byte each), it would allocate 4 bytes but it would treat it like 4 longs which use 8 bytes each for a total of 24 bytes; way above the 4 allocated. Lets go back to numwrite and create a bunch of chars. 
<br/>
![Segmentation fault](screenshots/SegFault.PNG)
<br/>
SEGMENTATION FAULT! This is looking promising. 

## Exploiting the bug
Lets open it up in edb and see what I broke.
<br/>
![Segmentation Fault EDB](secreenshots/SegFaultEDB.PNG)
<br/>
It seg faulted trying to write an odd number (0x6f686365) to a pointer I control. hmmm, that's odd but not too useful. Lets figure out what number I enter ends up writing to RAX. The easy way to do this would have been to just enter the number that matches each entry (ie, 1 for number 1, 2 for number 2, etc). Instead, out of habit of using letters as my intputs while testing, I created a script that would create the string of characters (ie, "AAAA\n" for number 1, "BBBB\n" for number2, etc) and convert it to an intager. While this does help make my numbers stand out, it just ate up a bunch of time. 
```Note: values that are over 32 bit may cause issues (infinite loop). This will be touched on later.```
At this point, I kept making a mistake and it took me far longer than I'd like to admit to figure out what was going on. I kept changing how many numbers I wrote. This would cuase the program to allocate a diffrent size buffer which would then cause different numbers to overlap. At this point I realized that I needed to get some sleep. The next morning, I relized my mistake and used a fixed number of 8 numbers which I will be using for the remainder of this writeup.

TODO:
- pointing 3 to writable mem
- check what gets placed there
- changing 5 to new count
- changing 11 to diff locations
- trying to write to options
- arbatrary write
> - overlapping echo and output
> - write to options
> - write to output.txt
> - reverse ascii string
