# Introduction
Preface: I do not know how this program works. I do not know how my exploit works. I accidentally stumbled into a solution and thought that this was supposed to be an easy challenge.
This writeup is not an explanation of how poly is intended to work, it's my process of how I exploited it. 

## TL;DR
Found a bug when adding 3 items and updating them with long strings which allowed arbitrary control of the RIP. 
 
## Tools used
 - Ghidra
> For static analysis
 - Evan's Debugger (edb)
> For dynamic analysis (debugging)
 - msf-pattern
> For finding buffer offsets.
> Could have also used pwn cyclic but didn't have it on hand
 - Python/PwnTools
> For exploit writing/testing

# Finding a bug
## Overview of the source
The first thing I looked at was the source code(poly.cpp) to get a quick idea of what the executable is and the probable way to win.
The key thing I noticed was the "win" function which would read and print the flag. ##TODO: ADD IMG##
Searching for "win" in the source didn't show any other results which indicates that the function isn't called in the program and is probably something that I will need to use an exploit to call.
Looking through the rest of the source code showed that it was a well written object-oriented c++ code with no obvious faults.
 
Endstate:
> There is a win function
> The executable is an object-oriented c++ program
 
## Understanding the program
I then ran the executable to get an idea of what the intended operation of the executable was. ##TODO: ADD IMG##
Seeing that I was only able to add items to a list or update items, that was only a limited number of possible exploits I could think of:
### Updating an empty list
Didn't work, just returned to the main menu
### Invalid character in the main menu
Didn't work, just exited the program
### Overflow with adding too many items
Never tested, I found another exploit before I tested this.
### Input buffer overflow in the main menu
Didn't work, just exited the program
### Input buffer overflow in the Add Item menu
"Unknown Error. No Item Create." Huh, that's odd. Maybe I can update an empty list now (didn't work)
### Buffer overflow in the Update All menu
"Unknown Error. Item will be removed." Now that's really interesting. I now have a way to delete items which opens up a bunch of exploits
 
## Testing with remove / Finding a bug
Removing items from a list tends to cause issues at the best of times. Finding an unintentional remove definitely caught my attention. This increases the number of possible exploits:
### Removing from an empty list
Not possible as I need an Item in the list to call Update.
### Use after free
What happens if I add 3 items, delete the middle one(Item 1), and update again? Does it still try to update Item 2? Doesn't work, just updates the first(Item 0) and third item(Item 2).
What if I add another item after that? Is it inserted into the space that was deleted? Doesn't work, it just adds a new item to the end of the list.
 
### Removing the root node
What happens when I remove the first item in the list? Does the list pointer get updated properly? Let's create 3 items and remove the first item. Wait, why did the update go from item 0 to item 2? What happens when I delete item 2 in this bugged state? It's now updating item 15540240; that's not right. What if I remove it as well?
SEGMENTATION FAULT!!! I think I just found my foot in the door.
 
## Exploiting a bug
Lets rerun this in edb and see what the Seg fault is.
"The address 0x0000000061616161 does not appear to be mapped". Nice, something is trying to access memory that we now control.
'''
Note: 0x61 is the ascii value for the letter 'A', the value I used to remove items.
'''
But what registers/stack values do I control that's causing this? It's not a return address on the stack, or some general purpose register. IT'S THE INSTRUCTION POINTER(RIP). With this, I can run any piece of executable code which includes the "win" function from earlier.
So now I have a long string and I know that the program is trying to use 4 bytes somewhere in that string as the instruction pointer, but how do I find where that is to change it to point to the win function? While I could just set the entire string to the address of the win function, I instead used msf-pattern to find where in the string the RIP is being set. msf-pattern_create creates a string that when you pass a substring of it to msf-pattern_offset, it tells you how many characters from the start of the string that you can find that substring (if it exists). So I created a pattern of length 100, reran poly in edb, and used the pattern instead of the long string of ‘A’s. Running this set the RIP to 0x61643561 and entering that into msf-pattern_create gave me an exact match at offset 16. I then created my own string of 16 ‘A’s and 4 ‘B’ (“AAAAAAAAAAAAAAAABBBB”) to confirm it works and that the RIP is set to BBBB. And it didn’t work; RIP was set to 0x00. I don’t remember how I figured it out during the CTF, but by adding a few more character at the end of my string (“AAAAAAAAAAAAAAAABBBBCCCC”)got it working again and set RIP to 0x42424242 as expected. 
Now all I need is the address of the “win” function. To do this, I opened up ghydra, searched the symbol tree for win, and copied the address. Other ways I could have done this is by looking in edb by using the function finder, or using the ELF class in pwntools.
## Writing the exploit
Like most of the exploits I write, I decided to use python with pwntools. For those who are unfamiliar with pwntools, it’s a python library designed specifically for quickly writing exploits for CTFs. For this exploit, all I needed was a way to convert the “win” function’s hex address to printable bytes with the p32 function (pack 32bit). To create the three items, I sent 6 “1”s (first 1 to select “Add Item” and a second 1 to set the value of that item). I then sent a “2” to select “update items”. After that, I started sending my buffers, the 16 ‘A’s, the packed “win” address, and the extra padding at the end. Because the standard print function doesn’t display bytes/and non-printable characters as expected, I instead use sys.stdout.buffer.write to output my exploit to the terminal. From there I am able to pipe it into ./poly, edb, or netcat as needed. I first ran it locally against ./poly with my own flag file to confirm that it was functioning as intended, and then ran on the test server.
 
